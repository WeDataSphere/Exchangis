/*!
 * @form-create/component-antdv-upload v3.1.3
 * (c) 2018-2022 xaboy
 * Github https://github.com/xaboy/form-create with upload
 * Released under the MIT License.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FcUpload = {}, global.Vue));
})(this, (function (exports, vue) { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function toString(val) {
    return val == null ? '' : _typeof(val) === 'object' ? JSON.stringify(val, null, 2) : String(val);
  }

  function toArray(value) {
    return Array.isArray(value) ? value : [null, undefined, ''].indexOf(value) > -1 ? [] : [value];
  }

  function getSlot(slots, exclude) {
    return Object.keys(slots).reduce(function (lst, name) {
      if (!exclude || exclude.indexOf(name) === -1) {
        lst.push(slots[name]);
      }

      return lst;
    }, []);
  }

  var script = {
    name: 'PlusOutlined'
  };

  var _hoisted_1 = {
    "class": "anticon"
  };

  var _hoisted_2 = /*#__PURE__*/vue.createElementVNode("svg", {
    height: "1em",
    width: "1em",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
  }, [/*#__PURE__*/vue.createElementVNode("defs"), /*#__PURE__*/vue.createElementVNode("path", {
    d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z",
    fill: "currentColor"
  }), /*#__PURE__*/vue.createElementVNode("path", {
    d: "M176 474h672q8 0 8 8v60q0 8-8 8H176q-8 0-8-8v-60q0-8 8-8z",
    fill: "currentColor"
  })], -1);

  var _hoisted_3 = [_hoisted_2];
  function render(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("span", _hoisted_1, _hoisted_3);
  }

  script.render = render;

  var parseFile = function parseFile(file, uid) {
    return {
      url: file,
      name: getFileName(file),
      status: 'done',
      uid: uid + 1
    };
  },
      getFileName = function getFileName(file) {
    return toString(file).split('/').pop();
  },
      parseUpload = function parseUpload(file) {
    return {
      url: file.url,
      file: file
    };
  };

  var NAME = 'fcUpload';
  var Upload = vue.defineComponent({
    name: NAME,
    inheritAttrs: false,
    formCreateParser: {
      toFormValue: function toFormValue(value) {
        return toArray(value);
      },
      toValue: function toValue(formValue, ctx) {
        return ctx.prop.props.limit === 1 ? formValue[0] || '' : formValue;
      }
    },
    props: {
      limit: {
        type: Number,
        "default": 0
      },
      modelValue: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      onSuccess: {
        type: Function,
        required: true
      },
      onPreview: Function,
      modalTitle: String,
      previewMask: undefined
    },
    emits: ['update:modelValue', 'change'],
    data: function data() {
      var fileList = this.modelValue.map(parseFile);
      return {
        defaultUploadList: fileList,
        previewImage: '',
        previewVisible: false,
        uploadList: fileList.map(parseUpload)
      };
    },
    watch: {
      modelValue: function modelValue(n) {
        var fileList = n.map(parseFile);
        this.$refs.upload.sFileList = fileList;
        this.uploadList = fileList.map(parseUpload);
      }
    },
    methods: {
      handlePreview: function handlePreview(file) {
        if (this.onPreview) {
          this.onPreview.apply(this, arguments);
        } else {
          this.previewImage = file.url;
          this.previewVisible = true;
        }
      },
      handleChange: function handleChange(_ref) {
        var file = _ref.file,
            fileList = _ref.fileList;
        this.$emit.apply(this, ['change'].concat(Array.prototype.slice.call(arguments)));
        var list = this.uploadList;

        if (file.status === 'done') {
          this.onSuccess(file, fileList);
          if (file.url) list.push({
            url: file.url,
            file: fileList[fileList.length - 1]
          });
          this.input();
        } else if (file.status === 'removed') {
          list.forEach(function (v, i) {
            if (v.file === file) {
              list.splice(i, 1);
            }
          });
          this.input();
        }
      },
      input: function input() {
        this.$emit('update:modelValue', this.uploadList.map(function (v) {
          return v.url;
        }));
      }
    },
    render: function render() {
      var _this$$slots$default,
          _this$$slots,
          _this = this;

      var isShow = !this.limit || this.limit > this.uploadList.length;
      return vue.createVNode(vue.Fragment, null, [vue.createVNode(vue.resolveComponent("AUpload"), vue.mergeProps({
        "list-type": 'picture-card'
      }, this.$attrs, {
        "onPreview": this.handlePreview,
        "onChange": this.handleChange,
        "ref": "upload",
        "defaultFileList": this.defaultUploadList
      }), _objectSpread2({
        "default": function _default() {
          return [isShow ? ((_this$$slots$default = (_this$$slots = _this.$slots)["default"]) === null || _this$$slots$default === void 0 ? void 0 : _this$$slots$default.call(_this$$slots)) || vue.createVNode(script, {
            "style": 'font-size: 16px; width: 16px;'
          }, null) : null];
        }
      }, getSlot(this.$slots, ['default']))), vue.createVNode(vue.resolveComponent("aModal"), {
        "mask": this.previewMask,
        "title": this.modalTitle,
        "visible": this.previewVisible,
        "onCancel": function onCancel() {
          return _this.previewVisible = false;
        },
        "footer": null
      }, {
        "default": function _default() {
          return [vue.createVNode("img", {
            "style": "width: 100%",
            "src": _this.previewImage
          }, null)];
        }
      })]);
    }
  });

  exports["default"] = Upload;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
