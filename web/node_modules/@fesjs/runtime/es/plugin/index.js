function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/**
 * @copy 该文件代码大部分出自 umi，有需要请参考：
 * https://github.com/umijs/umi/blob/master/packages/runtime/src/Plugin/Plugin.ts
 */
import { assert } from '../utils';

function _compose({
  fns,
  args
}) {
  if (fns.length === 1) {
    return fns[0];
  }

  const last = fns.pop();
  return fns.reduce((a, b) => () => b(a, args), last);
}

function isPromiseLike(obj) {
  return !!obj && typeof obj === 'object' && typeof obj.then === 'function';
}

export const ApplyPluginsType = {
  compose: 'compose',
  event: 'event',
  modify: 'modify'
};
export default class Plugin {
  constructor(opts) {
    this.validKeys = (opts === null || opts === void 0 ? void 0 : opts.validKeys) || [];
    this.hooks = {}; // 共享

    this.shared = {};
  }

  share(key, obj) {
    assert(!Object.keys(this.shared).includes(key), 'share failed, key repeat');
    this.shared[key] = obj;
  }

  getShared(key) {
    return this.shared[key];
  }

  register(plugin) {
    assert(!!plugin.apply, 'register failed, plugin.apply must supplied');
    assert(!!plugin.path, 'register failed, plugin.path must supplied');
    Object.keys(plugin.apply).forEach(key => {
      assert(this.validKeys.indexOf(key) > -1, `register failed, invalid key ${key} from plugin ${plugin.path}.`);
      if (!this.hooks[key]) this.hooks[key] = [];
      this.hooks[key] = this.hooks[key].concat(plugin.apply[key]);
    });
  }

  getHooks(keyWithDot) {
    const [key, ...memberKeys] = keyWithDot.split('.');
    let hooks = this.hooks[key] || [];

    if (memberKeys.length) {
      hooks = hooks.map(hook => {
        try {
          let ret = hook;

          for (const memberKey of memberKeys) {
            ret = ret[memberKey];
          }

          return ret;
        } catch (e) {
          return null;
        }
      }).filter(Boolean);
    }

    return hooks;
  }

  applyPlugins({
    key,
    type,
    initialValue,
    args,
    async
  }) {
    const hooks = this.getHooks(key) || [];

    if (args) {
      assert(typeof args === 'object', 'applyPlugins failed, args must be plain object.');
    }

    switch (type) {
      case ApplyPluginsType.modify:
        if (async) {
          return hooks.reduce( /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(function* (memo, hook) {
              assert(typeof hook === 'function' || typeof hook === 'object' || isPromiseLike(hook), `applyPlugins failed, all hooks for key ${key} must be function, plain object or Promise.`);

              if (isPromiseLike(memo)) {
                memo = yield memo;
              }

              if (typeof hook === 'function') {
                const ret = hook(memo, args);

                if (isPromiseLike(ret)) {
                  return ret;
                }

                return ret;
              }

              if (isPromiseLike(hook)) {
                hook = yield hook;
              }

              return _objectSpread(_objectSpread({}, memo), hook);
            });

            return function (_x, _x2) {
              return _ref.apply(this, arguments);
            };
          }(), isPromiseLike(initialValue) ? initialValue : Promise.resolve(initialValue));
        }

        return hooks.reduce((memo, hook) => {
          assert(typeof hook === 'function' || typeof hook === 'object', `applyPlugins failed, all hooks for key ${key} must be function or plain object.`);

          if (typeof hook === 'function') {
            return hook(memo, args);
          }

          return _objectSpread(_objectSpread({}, memo), hook);
        }, initialValue);

      case ApplyPluginsType.event:
        return hooks.forEach(hook => {
          assert(typeof hook === 'function', `applyPlugins failed, all hooks for key ${key} must be function.`);
          hook(args);
        });

      case ApplyPluginsType.compose:
        return () => _compose({
          fns: hooks.concat(initialValue),
          args
        })();

      default:
        return null;
    }
  }

}