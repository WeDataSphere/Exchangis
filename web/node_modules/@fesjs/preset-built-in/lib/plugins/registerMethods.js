"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _assert = _interopRequireDefault(require("assert"));

var _path = require("path");

var _fs = require("fs");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(api) {
  ['onExit', 'onGenerateFiles', 'addPluginExports', 'addCoreExports', 'addRuntimePluginKey', 'addRuntimePlugin', 'addEntryImportsAhead', 'addEntryImports', 'addEntryCodeAhead', 'addEntryCode', 'addBeforeMiddlewares', 'addHTMLHeadScripts', 'addMiddlewares', 'modifyRoutes', 'modifyBundleConfigOpts', 'modifyBundleConfig', 'modifyBabelOpts', 'modifyBabelPresetOpts', 'chainWebpack', 'addTmpGenerateWatcherPaths', 'modifyPublicPathStr'].forEach(name => {
    api.registerMethod({
      name
    });
  });
  api.registerMethod({
    name: 'writeTmpFile',

    fn({
      path,
      content
    }) {
      (0, _assert.default)(api.stage >= api.ServiceStage.pluginReady, 'api.writeTmpFile() should not execute in register stage.');
      const absPath = (0, _path.join)(api.paths.absTmpPath, path);
      api.utils.mkdirp.sync((0, _path.dirname)(absPath));

      if (!(0, _fs.existsSync)(absPath) || (0, _fs.readFileSync)(absPath, 'utf-8') !== content) {
        (0, _fs.writeFileSync)(absPath, content, 'utf-8');
      }
    }

  });
  api.registerMethod({
    name: 'copyTmpFiles',

    fn({
      namespace,
      path,
      ignore
    }) {
      (0, _assert.default)(api.stage >= api.ServiceStage.pluginReady, 'api.copyTmpFiles() should not execute in register stage.');
      (0, _assert.default)(path, 'api.copyTmpFiles() should has param path');
      (0, _assert.default)(namespace, 'api.copyTmpFiles() should has param namespace');
      const files = api.utils.glob.sync('**/*', {
        cwd: path
      });
      const base = (0, _path.join)(api.paths.absTmpPath, namespace);
      files.forEach(file => {
        const source = (0, _path.join)(path, file);
        const target = (0, _path.join)(base, file);

        if (!(0, _fs.existsSync)((0, _path.dirname)(target))) {
          api.utils.mkdirp.sync((0, _path.dirname)(target));
        }

        if ((0, _fs.statSync)(source).isDirectory()) {
          api.utils.mkdirp.sync(target);
        } else if (Array.isArray(ignore)) {
          if (!ignore.some(pattern => new RegExp(pattern).test(file))) {
            (0, _fs.copyFileSync)(source, target);
          }
        } else {
          (0, _fs.copyFileSync)(source, target);
        }
      });
    }

  });
}