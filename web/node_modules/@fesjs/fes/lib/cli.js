"use strict";

var _utils = require("@fesjs/utils");

var _serviceWithBuiltIn = require("./serviceWithBuiltIn");

var _fork = _interopRequireDefault(require("./utils/fork"));

var _getCwd = _interopRequireDefault(require("./utils/getCwd"));

var _getPkg = _interopRequireDefault(require("./utils/getPkg"));

var _package = _interopRequireDefault(require("../package.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const requiredVersion = _package.default.engines.node;

function checkNodeVersion(wanted, id) {
  if (!_utils.semver.satisfies(process.version, wanted, {
    includePrerelease: true
  })) {
    console.log(_utils.chalk.red(`You are using Node ${process.version}, but this version of ${id} requires Node ${wanted}.\nPlease upgrade your Node version.`));
    process.exit(1);
  }
}

checkNodeVersion(requiredVersion, '@fesjs/fes'); // process.argv: [node, fes.js, command, args]

const rawArgv = process.argv.slice(2);
const args = (0, _utils.yParser)(rawArgv);

(async () => {
  try {
    const command = args._[0];

    if (command === 'dev') {
      const child = (0, _fork.default)({
        scriptPath: require.resolve('./forkedDev')
      }); // ref:
      // http://nodejs.cn/api/process/signal_events.html

      process.on('SIGINT', () => {
        child.kill('SIGINT');
        process.exit(1);
      });
      process.on('SIGTERM', () => {
        child.kill('SIGTERM');
        process.exit(1);
      });
    } else {
      if (command === 'build') {
        process.env.NODE_ENV = 'production';
      }

      await new _serviceWithBuiltIn.Service({
        cwd: (0, _getCwd.default)(),
        pkg: (0, _getPkg.default)(process.cwd()),
        fesPkg: _package.default
      }).run({
        args,
        rawArgv
      });
    }
  } catch (e) {
    console.error(_utils.chalk.red(e.message));
    console.error(e.stack);
    process.exit(1);
  }
})();